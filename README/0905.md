2017/09/05

# Ajax
비동기적인 웹 어플리케이션의 제작을 위한 클라이언트 측 웹 개발 기법을 뜻하나 요즘은 의미가 변형되어 웹 브라우저에서 XMLHttpRequest 혹은 fetch를 이용해서 보내는 HTTP 요청을 통칭하기도 함  
## Ajax model
![](./img/ajax.jpg)

## Ajax의 장점
- 화면 전체를 다시 로드하지 않고도 내용을 갱신할 수 있어 더 나은 사용자 경험 제공  
- 서버의 응답을 기다리는 동안에도 여천히 웹 어플리케이션을 사용 가능
- 필요한 자원만 서버에서 받아오게 되므로 트래픽이 줄어듬(페이지를 전환하는 식으로 짜게되면 매번 요청을 보내야하는데 Ajax를 사용하면 JSON형식으로 줄어들게 가져온다.)

## Ajax의 단점
- 클라이언트 구현이 굉장히 복잡해짐

## Axios
- 브라우저와 Node.js에서 모두 사용 가능
- XMLHttpRequest, fetch에 비해 사용하기 편하고 기능이 더 많음
- Promise based HTTP client

## HTTP 메소드
GET - 자료읽기 (data만 받아옴)  
```js
// GET
axios.get('/api/todos')
  .then(res => {
    prettyPrint(res.data)
  })
```
POST - 자료생성 (data를 뒤에 붙여서 요청을 보낼 수 있다.)  
```js
// POST
axios.post('/api/todos', {title: "ajax 공부"})
  .then(res => {
    prettyPrint(res.data)
  })
```
PUT(치환) & PATCH(갱신)   
```js
// PATCH
axios.patch('/api/todos/3', {title: "axios 공부"})
  .then(res => {
    prettyPrint(res.data)
  })
```
DELETE - 삭제  
```js
// DELETE
axios.delete('/api/todos/3')
  .then(res => {
    prettyPrint(res.data)
  })

```
HEAD OPTION  
TRACE CONNECT  
주로 GET, POST, PATCH, DELATE를 사용한다.  

## JSON의 특별한 기능
- 원하는 data를 선택해서 가져올 수 있다.  


## GET /api/todos/?title=react
axios 요청 메소드의 두 번째 인자로 config 객체를 넘길 수 있습니다. config 객체를 통해 요청의 쿼리 스트링, 요청 헤더, 쿠키 포함 여부 등 많은 것들을 설정할 수 있습니다.  
```js
// config 객체
axios.get('/api/todos', {
  params: { // query string
    title: 'react 공부'
  },
  headers: { // 요청 헤더
    'X-Api-Key': 'my-api-key'
  },
  timeout: 1000 // 1초 이내에 응답이 오지 않으면 에러로 간주
}).then(res => {
    prettyPrint(res.data)
  })
```
### promise에 오류를 잡는 방법
- .then뒤에 catch를 붙이고 에로우함수를 써서 에러를 잡아낸다.  

## 응답 객체
응답 객체를 통해 응답의 여러 정보에 접근할 수 있습니다.
```js
// config.params
axios.get('/api/todos/1')
  .then(res => {
    console.log(`status code: ${res.status}`)
    console.log('headers:')
    prettyPrint(res.headers)
    console.log('data:')
    prettyPrint(res.data)
  })
```

## 쿠키를 통한 인증 예제
- 로그인
```js
// 로그인
axios.post('/auth', {
  username: 'fast',
  password: 'campus'
}).then(res => {
  prettyPrint(res.data)
})
```

- 로그아웃
```js
// 로그아웃
axios.delete('/auth')
  .then(res => {
    prettyPrint(res.data)
  })
```

```js
// 로그인을 위한 라우트 핸들러
// 인증을 위한 라우트 핸들러입니다.
server.post('/auth', bodyParser.json(), (req, res) => {
  const {username, password} = req.body
  const matched = users.find(user => user.username === username && user.password === password)
  if (matched) {
    req.session.username = username
    res.end({ok: true, data: {.....}})
  } else {
    res.status(400)
    res.end({ok: false, error: '400 Bad Request'})
  }
})
```
`const {username, password} = req.body`와 `const username = req.body.username`과 `const password = req.body.password`로 나누어 써주어도 된다.  
성공을 하였을 때 `res.end{ok: true}`로 반환해주는 것이 관습이다. 이때 성공하였을 때 데이터를 넘겨줄 때는 `res.end{ok: true, data: {.....}}`를 사용하면 된다.  
실패하였을 때는 `res.end{ok: false, error: '400 Bad Request'}`를 사용해주는 것이 관습이다.  

```js
// `/api` 경로의 인증을 담당하는 미들웨어입니다.
function authMiddleware(req, res, next) {
  if (!req.session.username) {
    res.status(401)
    res.send('401 Unauthorized')
  } else {
    next()
  }
}
```
위의 코드에서 `res.send('401 Unauthorized')`대신 `res.end()`를 사용해주는 것이 좋다. 왜냐면 데이터를 서버와 요청과 응답을 하여야 하는데 send는 사용자에게 글로 표시해주는 것이기 때문에 무의미하다.  

## 가장 많이 사용되는 것
render / send / redirect / end  

# CORS
보내는 쪽과 받는 쪽의 URL이 다를 때 문제가 생긴다.  
## Same-origin Policy(동일 출처 정책)
- 이지에서 리소스를 불러올 때, 리소스의 출처가 웹페이지의 출처와 같으면 안전하다고 보고, 출처가 다르면 해당 리소스는 안전하지 않다고 보는 원칙
- 여기서 `'출처'`란 `'프로토콜 + 도메인 + 포트번호'`의 결합을 가리킴. 즉, 세 개가 다 같아야 동일 출처라고 할 수 있고, 셋 중에 하나라도 다르면 동일 출처로 간주되지 않음
- 웹 보안의 기본 원칙으로, 웹 브라우저의 많은 요소에 적용됨


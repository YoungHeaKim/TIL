2017/09/05

# Ajax
비동기적인 웹 어플리케이션의 제작을 위한 클라이언트 측 웹 개발 기법을 뜻하나 요즘은 의미가 변형되어 웹 브라우저에서 XMLHttpRequest 혹은 fetch를 이용해서 보내는 HTTP 요청을 통칭하기도 함  
## Ajax model
![](./img/ajax.jpg)

## Ajax의 장점
- 화면 전체를 다시 로드하지 않고도 내용을 갱신할 수 있어 더 나은 사용자 경험 제공  
- 서버의 응답을 기다리는 동안에도 여천히 웹 어플리케이션을 사용 가능
- 필요한 자원만 서버에서 받아오게 되므로 트래픽이 줄어듬(페이지를 전환하는 식으로 짜게되면 매번 요청을 보내야하는데 Ajax를 사용하면 JSON형식으로 줄어들게 가져온다.)

## Ajax의 단점
- 클라이언트 구현이 굉장히 복잡해짐

## Axios
- 브라우저와 Node.js에서 모두 사용 가능
- XMLHttpRequest, fetch에 비해 사용하기 편하고 기능이 더 많음
- Promise based HTTP client

## HTTP 메소드
GET - 자료읽기 (data만 받아옴)  
```js
// GET
axios.get('/api/todos')
  .then(res => {
    prettyPrint(res.data)
  })
```
POST - 자료생성 (data를 뒤에 붙여서 요청을 보낼 수 있다.)  
```js
// POST
axios.post('/api/todos', {title: "ajax 공부"})
  .then(res => {
    prettyPrint(res.data)
  })
```
PUT(치환) & PATCH(갱신)   
```js
// PATCH
axios.patch('/api/todos/3', {title: "axios 공부"})
  .then(res => {
    prettyPrint(res.data)
  })
```
DELETE - 삭제  
```js
// DELETE
axios.delete('/api/todos/3')
  .then(res => {
    prettyPrint(res.data)
  })

```
HEAD OPTION  
TRACE CONNECT  
주로 GET, POST, PATCH, DELATE를 사용한다.  

## JSON의 특별한 기능
- 원하는 data를 선택해서 가져올 수 있다.  


## GET /api/todos/?title=react
axios 요청 메소드의 두 번째 인자로 config 객체를 넘길 수 있습니다. config 객체를 통해 요청의 쿼리 스트링, 요청 헤더, 쿠키 포함 여부 등 많은 것들을 설정할 수 있습니다.  
```js
// config 객체
axios.get('/api/todos', {
  params: { // query string
    title: 'react 공부'
  },
  headers: { // 요청 헤더
    'X-Api-Key': 'my-api-key'
  },
  timeout: 1000 // 1초 이내에 응답이 오지 않으면 에러로 간주
}).then(res => {
    prettyPrint(res.data)
  })
```
### promise에 오류를 잡는 방법
- .then뒤에 catch를 붙이고 에로우함수를 써서 에러를 잡아낸다.  

## 응답 객체
응답 객체를 통해 응답의 여러 정보에 접근할 수 있습니다.
```js
// config.params
axios.get('/api/todos/1')
  .then(res => {
    console.log(`status code: ${res.status}`)
    console.log('headers:')
    prettyPrint(res.headers)
    console.log('data:')
    prettyPrint(res.data)
  })
```

## 쿠키를 통한 인증 예제
- 로그인
```js
// 로그인
axios.post('/auth', {
  username: 'fast',
  password: 'campus'
}).then(res => {
  prettyPrint(res.data)
})
```

- 로그아웃
```js
// 로그아웃
axios.delete('/auth')
  .then(res => {
    prettyPrint(res.data)
  })
```

```js
// 로그인을 위한 라우트 핸들러
// 인증을 위한 라우트 핸들러입니다.
server.post('/auth', bodyParser.json(), (req, res) => {
  const {username, password} = req.body
  const matched = users.find(user => user.username === username && user.password === password)
  if (matched) {
    req.session.username = username
    res.end({ok: true, data: {.....}})
  } else {
    res.status(400)
    res.end({ok: false, error: '400 Bad Request'})
  }
})
```
`const {username, password} = req.body`와 `const username = req.body.username`과 `const password = req.body.password`로 나누어 써주어도 된다.  
성공을 하였을 때 `res.end{ok: true}`로 반환해주는 것이 관습이다. 이때 성공하였을 때 데이터를 넘겨줄 때는 `res.end{ok: true, data: {.....}}`를 사용하면 된다.  
실패하였을 때는 `res.end{ok: false, error: '400 Bad Request'}`를 사용해주는 것이 관습이다.  

```js
// `/api` 경로의 인증을 담당하는 미들웨어입니다.
function authMiddleware(req, res, next) {
  if (!req.session.username) {
    res.status(401)
    res.send('401 Unauthorized')
  } else {
    next()
  }
}
```
위의 코드에서 `res.send('401 Unauthorized')`대신 `res.end()`를 사용해주는 것이 좋다. 왜냐면 데이터를 서버와 요청과 응답을 하여야 하는데 send는 사용자에게 글로 표시해주는 것이기 때문에 무의미하다.  

## 가장 많이 사용되는 것
render / send / redirect / end  

# CORS
보내는 쪽과 받는 쪽의 URL이 다를 때 문제가 생긴다.  
## Same-origin Policy(동일 출처 정책)
- 이지에서 리소스를 불러올 때, 리소스의 출처가 웹페이지의 출처와 같으면 안전하다고 보고, 출처가 다르면 해당 리소스는 안전하지 않다고 보는 원칙
- 여기서 `'출처'`란 `'프로토콜 + 도메인 + 포트번호'`의 결합을 가리킴. 즉, 세 개가 다 같아야 동일 출처라고 할 수 있고, 셋 중에 하나라도 다르면 동일 출처로 간주되지 않음
- 웹 보안의 기본 원칙으로, 웹 브라우저의 많은 요소에 적용됨

## Content-Security-Policy
Content-Security-Policy헤더(응답헤더)를 이용하면, 동일하지 않은 출처에 대한 리소스를 불러올지 말지 결정할 수 있음.  

##CORS (Cross-Origin Resource Sharing)
- 클라이언트 측 cross-origin 요청을 
- 안전하게 보낼 수 있는 방법을 정한 표준
- 쉽게 말하면, 스크립트가 전혀 다른 출처를 갖는 API 서버를 사용하려고 하는 상황에서는 뭔가 추가적인 처리를 해주어야 한다는 것!

## CORS에 관여하는 응답 헤더
Access-Control-Allow-Origin
Access-Control-Expose-Headers
Access-Control-Max-Age
Access-Control-Allow-Credentials
Access-Control-Allow-Methods
Access-Control-Allow-Headers

## CORS에 관여하는 요청 헤더
Origin  
Access-Control-Request-Method (preflighted 전용)  
Access-Control-Request-Headers (preflighted 전용)  

## CORS - Safe, Unsafe
- GET, HEAD 요청은 safe(읽기 전용)이기 때문에 서버에 요청이 도달한다고 해서 서버의 상태에 영향을 미칠 일은 없으므로, 웹 브라우저는 일단 해당 요청을 보내본다. 만약 서버가 cross-origin 요청을 허용한다고 응답하면 응답을 그대로 사용하고, 그렇지 않으면 에러
- POST, PUT, PATCH, DELETE 등의 메소드는 요청이 서버에 전송되는 것 자체가 위험하므로, 실제 요청을 보내기 전에 서버가 cross-origin 요청을 허용하는지를 알아보기 위해 시험적으로 요청을 한 번 보내본다. 이 요청을 preflighted request라고 한다.

## CORS with credentials
- cross-origin 요청에는 기본적으로 쿠키가 포함되지 않으나, XMLHttpRequest 혹은 fetch를 통해서 요청을 보낼 때 쿠키를 포함시키는 옵션을 줄 수 있고 이 때 CORS 요건이 더 엄격해짐  
- Access-Control-Allow-Credentials 헤더 설정 필요, Access-Control-Allow-Origin 헤더에 와일드카드 허용 안됨  

# Access Token & JWT
## 쿠키의 단점
- 쿠키를 지원하는 클라이언트에서 밖에 사용할 수 없음(모바일에서 쿠키를 사용하게 되면 웹브라우저를 하나 두어야한다.)
- 적절히 관리되지 않은 쿠키는 보안에 취약하며, 관리를 하려고 해도 CORS 대응이 복잡함
- 같은 서버에 요청을 할 때마다 쿠키는 자동으로 보내주기 때문에 좋지않다.  

## Token Based Auth
- 토큰이란, 사용자의 자격증명(아이디, 패스워드 등)을 통해 인증이 이루어진 후, 특정 자원에 대한 자격증명으로서 대신 사용되는 인증 수단
- 서버에 요청을 할 때마다 토큰을 요청에 직접 포함시켜서 전송 (주로 Authorization 헤더에 넣어서 전송)

![](./img/token.png)

## Cookie vs Token
![](./img/cookie.png)  
클라이언트 측 자바스크립트 자체가 토큰을 저장, 전송을 함

## 토큰 사용의 장점
다양한 인증 수단(전화번호, 공인인증서, 생체정보 등)의 인증 결과를 토큰이라는 하나의 수단으로 통일할 수 있음  
쿠키를 사용하지 않음으로써 CORS 관련 문제를 회피할 수 있음  

## 토큰 사용의 단점
- 매 요청에 토큰이 포함되게 되므로 적당히 짧은 길이를 유지해야 함 (주의해야함)
- 토큰 유출에 대한 대비책이 필요 (토큰에 유효기간을 두거나, 유출된 토큰을 강제로 무효화하는 등의 방법을 사용)
- 쿠키와는 다르게, 클라이언트에서 직접 토큰을 저장하고 관리해야 함

## Web Storage
- 브라우저에서 키-값 쌍을 저장할 수 있는 저장소
- 쿠키에 비해 사용하기 편리하고 저장 가능한 용량도 큼(10MB 가량)
- 브라우저 탭이 닫히면 내용이 삭제되는 sessionStorage, 브라우저 탭이 닫혀도 내용이 유지되는 localStrage가 있음  
## Webstorage 실습
![](./img/webstorage.png)
값을 입력할땐 `localStorage.setItem`을 사용하고 값을 출력할 땐 `localStorage.getItem`을 사용한다.  
문자열만 저장가능하다.  

## 보안 상 주의사항
- 토큰을 localStorage에 저장하게 되면 자바스크립트로 토큰을 탈취할 수 있게 되므로, 웹사이트에 악성 스크립트를 삽입하는 공격(XSS)에 노출되지 않도록 신경써야 함
- 직접 DOM API를 사용하는 대신 EJS, React 같은 템플릿 언어를 사용하기만 해도 XSS에 대한 방어는 충분함
- **직접 DOM API에 innerHTML을 직접 사용하면 절대 안된다.**
- 암호화 보다는 서명화를 통해 하는 것이 CPU에게도 무리를 적게 주어 사용하는 데에 더 좋다.  

## JSON Web Token
- 최근 널리 사용되고 있는 토큰 형식의 표준
- 토큰 안에 JSON 형식으로 정보를 저장함
- 보안을 위해 서명 또는 암호화를 사용할 수 있음

(jwt.io)[https://jwt.io/]  

## Axios 이용하여 토큰 사용하기
```js
// 토큰 받아오기
let token;
axios.post('/auth', {
  username: 'fast',
  password: 'campus'
}).then(res => {
  token = res.data.token
  console.log(`token: ${token}`)
})
```
```js
// 토큰으로 요청하기 1
axios.get('/auth', {
  headers: {
    'Authorization': `Bearer ${token}`
  }
}).then(res => {
  prettyPrint(res.data)
})
```
```js
// 토큰으로 요청하기 2
axios.get('/some-api', {
  headers: {
    'Authorization': `Bearer ${token}`
  }
}).then(res => {
  prettyPrint(res.data)
})
```
```js
// 토큰으로 요청하기 3
axios.post('/count', null, {
  headers: {
    'Authorization': `Bearer ${token}`
  }
}).then(res => {
  prettyPrint(res.data)
})
```
위의 코드를 보면 여러개의 토큰 요청하기를 중복으로 사용하기 때문에 프로그래머라면 중복을 제거할 줄 알아야하기 때문에 Axios의 instance를 사용한다.  
```js
// Axios.create
const authedAxios = axios.create({
  headers: {
    'Authorization': `Bearer ${token}`
  }
})
authedAxios.get('/auth').then(res => {
  prettyPrint(res.data)
})
authedAxios.get('/some-api').then(res => {
  prettyPrint(res.data)
})
authedAxios.post('/count').then(res => {
  prettyPrint(res.data)
})
```

# Fetch API
- 웹 브라우저의 XMLHttpRequest를 대체하기 위해 만들어진 새로운 HTTP client 표준
- 비교적 최근에 도입되어 IE 및 구형 안드로이드 브라우저(4.x)는 지원하지 않음
- [Fetch Polyfill](https://github.com/github/fetch)
- [isomorphic-fetch](https://www.npmjs.com/package/isomorphic-fetch)  


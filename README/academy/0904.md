2017/09/04

# 모던웹 서비스의 구성요소
- - -
# Express Middleware
## Middleware의 생김새
```js
// 미들웨어 = 함수
function helloMiddleware(res, req, next) {
  console.log('hello')
  next()
}

app.use(helloMiddleware)
```
미들웨어는 함수이다.  
응답객체, 요청객체, next객체를 인자로 받는다.  
요청이 일어났을때마다 콘솔을 찍는다.  

## Middleware란?
- 함수, 즉 안에서 어떤 작업이든 가능
- request 객체, response 객체, next 함수를 인자로 받음
- request 객체 response 객체를 조작해서 기능구현  
- 다음 미들웨어를 동작시키기 위해 next 함수를 인자 없이 호출
- 등록된 순서대로 실행됨(이것이 중요하다.)

## app.use
미들웨어를 앱 전체에서 동작하도록 주입할 때
```js
app.use(helloMiddleware)
```

특정 경로에서만 동작하도록 주입
```js
app.use('/some-path', helloMiddleware)
```

한 번에 여러 개 주입
```js
app.use(middleware1, middleware2, middleware3, ...)
```

## 미들웨어로 하는 일
- 로깅(morgan사용)
- http body를 객체로 변환(body-parser)
- 사용자 인증
- 권한 관리(각 컨텐츠의 소유지만 수정 삭제 권한을 주는 관리)

## 미들웨어를 사용하는 이유
미들웨어로 할 수 있는 모든 일은 라우트 핸들러에서도 할 수 있으나, 여러 라우터에서 사용해야 하는 기능을 중복 작성하는 불편을 덜고 코드를 재사용하기 위해 미들웨어를 사용하는 것

## 미들웨어 생태계
- Express resource
- NPM search
위의 두개를 NPM에서 검색해보면 거의 웬만한 기능들은 다 있다.  

## Express 미들웨어 예제
### next?
미들웨어는 req, res에 더해서 next라는 함수를 추가로 인자로 받습니다. next 함수를 호출하면 다음 미들웨어로 처리를 넘기는 효과가 있습니다. 만약에 미들웨어가 next 함수를 호출하지도 않고, 응답도 보내지 않으면 클라이언트는 응답을 받지 못하게 되므로 주의해야 한다.  

브라우저는 기본적으로 요청을 두번 난리는데 이때 한번은 favicon.ico라는 것을 보낸다.  
node.js에서 만들 때는 exports를 사용한다.  

미들웨어에서 next를 보내거나 응답을 보내주어야 브라우저에서 받을 수 있다.  
locals라는 객체는 render해주는 것과 같이 동작한다.  
값을 변하지 않게 할 때는 locals를 쓰고 다른경우에는 render를 사용하는 것이 좋다.  
```js
exports.resLocalMiddleware = (req, res, next) => {
  res.locals.myVar = 'FASTCAMPUS!'
  next()
}
```
## App Local, Response Local
app.locals와 res.locals는 특별한 객체를 담고 있습니다. 템플릿에서는 res.render를 통해 명시적으로 주입받지 않아도 저 두 객체의 속성에 바로 접근할 수 있습니다.  
템플릿을 가리지 않고 사용되는 정보들, 예를 들어 '현재 로그인 중인 사용자 정보' 같은 것을 res.render에 매번 인자로 넘기는 것은 귀찮을 뿐더러 빠뜨리기도 쉽습니다. 그런 정보들을 템플릿에서 쉽게 사용하기 위해, app.locals나 res.locals에 우리가 원하는 이름으로 속성을 주입할 수 있습니다.  
app.locals는 앱 단위로 공통적으로 쓰이는 정보를 담는 목적으로 사용됩니다. res.locals는 각 요청마다 달라지는 정보를 담는 목적으로 사용됩니다.  
app.local 객체를 조작하는 것은 매우 쉽습니다. res 객체는 매 요청마다 새로 생성되어 미들웨어 바깥에서 접근할 수 있는 방법이 없으므로, res.locals를 조작하려면 미들웨어를 사용해야 합니다.  

## 클로저 함수
클로저를 사용하여 함수를 리턴하여 값을 저장하는 것을 클로저함수라 한다.  

## arrow 함수
```js
makeAdder2 = x => y => x+y
```
에로우 함수를 두개를 동시에 사용해주는대 이때 `y => x+y`를 괄호를 사용하여 묶어놓은 것을 말한다.   
자바스크립트 currying이라는 것을 검색해보고 참고하면된다.  

## lock
lock는 다른 함수들과 같은 코드를 사용하는데 다른 점은 `key =>`이부분이 추가된 것이다.  
lock은 미들웨어가 아니라 미들웨어를 만들어주는 함수이다.  

## 미들웨어 vs 라우트 핸들러
- 라우트 핸들러도 미들웨어이다. 그치만 특별하게 취급대는 것을 라우트 핸들러라 한다.  

## 404 페이지를 만드는 법
```js
app.use ((req, res, next) => {
  res.render('404.ejs')
})
```
위의 코드를 사용하여 404페이지를 만들 수 있다.  

## 에러 처리 미들웨어
###오류 처리
다른 미들웨어 함수와 동일반 방법으로 오류 처리 미들웨어 함수를 정의할 수 있지만, 오류 처리 함수는 3개가 아닌 4개의 인수, 즉 (err, req, res, next)를 갖는다는 점이 다릅니다.  

에러처리는 웹서버에서 어떠한 에러가 났을 때 슬랙에 연동하여 에러를 바로 처리할 수 있도록 만들 수 있다.  
Bugsnag을 이용하여 에러가 난 횟수를 그래프로 표출하고 어떠한 에러가 났는지 로그기록을 볼 수 있다.(에러처리 미들웨어)  
에러처리 미들웨어는 서비스하는 미들웨어가 있기 떄문에 직접 만들 일은 거의 없다.  
에러처리 미들웨어는 Sentry와 Bugsnag 등이 있다.  
[에러처리 미들웨어](https://expressjs.com/ko/guide/error-handling.html)

- - -
# Cookie
## 쿠키의 필요성
개별 클라이언트의 여러 요청에 걸친 정보의 유지
- 장바구니
- 로그인/로그아웃
- 방문기록
- 등등

## HTTP Cookie
- 서버가 응답을 통해 웹 브라우저에 저장하는 이름+값 형태의 정보
- 웹 브라우저는 쿠키를 저장하기 위한 저장소를 가지고 있음  
- 저장소는 자료의 유효기간과 접근 권한에 대한 다양한 옵션을 제공

## 쿠키 전송 절차
1. 서버 브라우저에 저장하고 싶은 정보를 응답과 같이 실어 보낸다.  
```js
HTTP/1.1 200 OK
Set-Cookie: cookieName=cookieValue; Secure; Max-Age=60000
...
```
2. 브라우저는 같은 서버에 요청이 일어날 때마다 해당 정보를 요청에 같이 실어서 서버에 보낸다.  
```js
GET / HTTP/1.1
Cookie: cookieName=cookieValue; anotherName=anotherValue
...
```

## Set-Cookie Options
Expires, Max-Age
  - 쿠키의 지속 시간 설정

Secure
  - HTTPS를 통해서만 쿠키가 전송되도록 설정

HttpOnly
  - 자바스크립트에서 쿠키를 읽지 못하도록 설정

Domain, Path
  - 쿠키의 scope 설정 (쿠키가 전송되는 URL을 제한)

## Express + Cookie
쿠키 읽기 - req.cookies
  - 요청에 실려온 쿠키가 객체로 변환되어 req.cookies에 저장됨(cookie-parser 미들웨어 필요)  

쿠키 쓰기 - res.cookie(name,value)
  - 쿠키의 생성 혹은 수정

## JavaScript + Cookie
자바스크립트로도 쿠키를 읽고 쓰는 방법이 존재하지만, 보안 상 문제를 일으킬 수 있으므로 이런 접근 방식은 거의 사용되지 않는다. (XSS의 방법의 해킹으로부터 방어)  
자바스크립트에서 쿠키에 접근하지 못하도록 HttpOnly를 항상 설정하는 것이 best practice  

## 쿠키의 한계점
US-ASCII 밖에 저장하지 못함. 보통 percent encoding을 사용  
4000 바이트 내외(영문 4000자, percent encoding 된 한글 444자 가량)밖에 저장하지 못함  
브라우저에 저장됨. 즉, 여러 브라우저에 걸쳐 공유되어야 하는 정보, 혹은 웹 브라우저가 아닌 클라이언트(모바일 앱)에 저장되어야 하는 정보를 다루기에는 부적절 (해당 브라우저에만 쿠키가 저장되기 때문에 다른 브라우저에서 사용하지 못한다.)  
웹브라우저와 모바일 장치에서 사용하게 되는 프로그램은 쿠키를 사용하지 않는 것이 좋다.  

- - -
# Session
## 사전적 의미
- (특정한 활동을 위한) 시간
- (의회 등의) 회기; (법정의) 개정 (기간)

## 실질적 의미(컴퓨터용어에서)
- 시작 조건과 종료 조건이 있는 시간, 또는 회기
- 정보 교환이 지속되는 시간, 또는 회기  

## 세션의 예
HTTP session
- 요청 - 응답

로그인 세션 (보통 운영체제에서 사용)
- 로그인 - 로그아웃

Google Analytics 세션 (페이지 사용자 수, 접속자 수 측정)
- 페이지 접속 - 30분간 접속이 없으면 종료로 간주 (커스터마이징 가능)

## 웹 서비스를 위한 세션의 구현
1. 세션이 시작(ex. 로그인)되면, 세션이 시작되었다는 사실을 쿠키에 저장 (세션의 시작은 우리가 설정하기 나름이다.)
2. 세션에 대한 정보를 여러 요청에 걸쳐서 지속시키기 위해, 정보를 어딘가(쿠키)에 저장
3. 세션이 만료되면, 세션이 만료되었다는 사실을 쿠키에 반영
* 위 방식은 널리 사용되는 방식일 뿐, 반드시 위와 같이 구현해야 하는 것은 아닙니다.

## 세션 스토어
세션에 대한 정보를 저장하는 어딘가
- 쿠키
- 데이터베이스
- 파일
- 기타 정보를 저장할 수 있는 곳 어디든

## 세션 스토어의 선택
서비스의 요구사항에 맞춰서  
적절한 저장소를 선택하면 됨  
- 정보의 형태가 간단하고 자주 바뀔 일이 없으면 쿠키
- 저장해야 할 정보의 양이 많으면 데이터베이스
- 정보가 굉장히 자주 변경되면 메모리 기반 저장소

## 세션? 세션 스토어?
- '세션'과 '세션 스토어'는 엄연히 다른 말이지만 혼용되는 경우가 많습니다.  
- '세션에 정보를 저장한다'는 말은 '세션 스토어에 정보를 저장한다'는 말과 같은 뜻이라고 생각하면 됩니다.  

## Express + Session
cookie-session
- 쿠키에 모든 정보를 저장하는 세션 스토어. 
- 첫 방문시 무조건 세션 시작

express-session
- 쿠키에는 세션 식별자만 저장하고 실제 정보의 저장은 외부 저장소(데이터베이스 등)를 이용하는 세션 스토어. 외부 저장소에 대한 별도의 설정 필요

##cookie-session 동작 방식
1. cookie-session 미들웨어는 첫 요청이 일어났을 때 빈 세션 정보(빈 객체)를 req.session에 주입합니다.
2. 프로그래머는 세션과 관련된 정보를 req.session에 저장합니다. req.session은 보통의 자바스크립트 객체로, JSON으로 표현될 수 있는 자료라면 뭐든지 저장할 수 있습니다.
3. cookie-session 미들웨어는 응답이 일어나기 직전에 req.session 객체를 문자열로 바꾼 뒤(JSON & base64), 쿠키에 저장합니다.
4. cookie-session 미들웨어는 다음 번 요청부터 쿠키에 저장된 정보를 자바스크립트 객체로 변환해 req.session에 주입합니다.
5. 프로그래머는 req.session 객체를 이용해 세션 정보를 읽을 수 있습니다. 또한 세션 정보를 통째로 삭제하기 위해  

쿠키에 대한 자세한 옵션은 미들웨어를 생성하는 곳에 설정을 한다.  

- - - 
# 해시 함수
원본이 변환되었는지 확인할 때 사용한다.  
같은 입력에 대해서는 같은 결과가 나온다.  
결과가 짧을수록 좋다.  
해시함수의 조건을 만들고 값을 넣으면 변형이 되었을 때는 다른값이 나온다.  
전체 자료에서 일부분을 찾는 조건을 만들어 변형이 되었는지 확인하는 방법이다.  

## 좋은 해시 함수
1. 결과가 짧으면 좋다.  
2. 해시 충돌(같은 해시값이 나온 경우)의 확률이 적어야 한다.  
3. MD5 Hash Generator를 사용한면 좋다.  

## 서명을 통한 보안
1. 조작 방지
2. 공개를 막아주지는 않는다.  